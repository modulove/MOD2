/*
HAGIWO MOD2 Clap Ver1.1 - With LED envelope display

  • TR‑808‑style digital hand‑clap: two short gated noise bursts followed by an exponential noise tail
  • LED brightness follows the envelope shape (bursts + decay)
  • 3 potentiometers → live control of BPF Q, decay time and BPF centre frequency
  • Accent input (GPIO0): HIGH = −6 dB (0.5× amplitude)
  • Fixed 3‑burst structure: two 4 ms noise gates spaced 15 ms apart + exponential tail (≤0.60 s)
  • One‑shot voice buffer: 22 000 samples @36.6 kHz (≈0.60 s) held in RAM

  --Pin assign---
POT1     A0       BPF Q (0.5 – 4.0)   — left = wide, right = narrow
POT2     A1       Decay time (20 – 200 ms)
POT3     A2       BPF Fc (50 Hz – 8 kHz)
IN1      GPIO7    External trigger (rising‑edge)
IN2      GPIO0    Accent — HIGH = ‑6 dB (0.5×)
CV       A2       Shared with POT3
BUTTON   GPIO6    Manual trigger (active‑low, pull‑up)
OUT      GPIO1    10‑bit PWM audio output
LED      GPIO5    Envelope LED output (PWM)
EEPROM    N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.

*/

#include <Arduino.h>            // Standard Arduino core
#include "hardware/pwm.h"       // RP2040 PWM hardware access
#include "hardware/irq.h"       // IRQ helpers
#include <math.h>               // mathf / sin / cos etc.

/**********************  === Core constants ===  *****************************/
const float    SYS_CLOCK = 150000000.0f;      // RP2040 system clock (150 MHz)
const float    AUDIO_FS  = SYS_CLOCK / 4096.0f; // ≈36.6 kHz playback ISR rate
const uint32_t TABLE_SZ  = 22000;             // 22 k‑sample buffer ≈0.60 s

// PWM output (10‑bit, centre‑aligned)
const float    PWM_FS   = 1023.0f;            // 10‑bit full‑scale value
const float    PWM_MID  = PWM_FS / 2.0f;      // Mid‑scale (silence)

// Global output gain
const float    AMP_SCALE    = 3.5f;           // Post‑mix gain factor
const float    MASTER_ATTEN = 0.8f;           // −1.9 dB master attenuation

// Anti‑click fades (in samples)
const uint16_t FADE_IN_SMP  = 70;             // 2 ms @36.6 kHz
const uint16_t FADE_OUT_SMP = 40;             // 1 ms @36.6 kHz

/**********************  === ADC setup ===  **********************************/
const uint8_t  ADC_RES_BITS = 10;             // 10‑bit ADC resolution
const uint16_t ADC_MAX_VAL  = (1 << ADC_RES_BITS) - 1;

/**********************  === Buffers / state ===  ****************************/
float   noiseTbl[TABLE_SZ];          // Pre‑generated white‑noise table
int16_t outClap[TABLE_SZ];           // Rendered voice buffer (int16 to save RAM)
uint16_t envTbl[TABLE_SZ];           // Envelope values for LED brightness

volatile bool     playingClap = false; // Playback state flag
volatile uint32_t idxClap     = 0;     // Current playback index

volatile float    decayMs     = 110.0f; // 20‑200 ms decay time (pot A1)
volatile float    bpfQ        = 2.25f;   // 0.5‑4.0 BPF Q factor (pot A0)
volatile float    fc          = 1500.0f; // 50‑8000 Hz centre freq (pot A2)
const   float     DECAY_CURVE = 2.0f;    // Fixed envelope curvature

volatile float    volFactor   = 1.0f;    // Accent volume (1.0 normal / 0.5 soft)
volatile bool     reqTrig     = false;   // Trigger request signalled by ISRs

uint sliceAudio, sliceIRQ, sliceLED;     // PWM slice indices

/**********************  === Helper ===  *************************************/
inline uint16_t readADC(uint8_t pin){ return analogRead(pin); } // Convenience wrapper

/**********************  === Noise table ===  ********************************/
void generateWhiteNoise(){               // Fill table with −1…+1 white noise
  for(uint32_t i=0;i<TABLE_SZ;++i)
    noiseTbl[i] = 2.0f*(rand()/(float)RAND_MAX) - 1.0f;
}

/**********************  === Voice builder ===  ******************************/
// Render full 22 k‑sample clap into outClap[] using current parameters
void buildClap(int16_t* dst, float decay_ms, float fcC, float qVal){
  /* --- 2‑pole band‑pass filter coefficients (Cookbook) --- */
  const float Q = qVal;
  float w0 = 2.0f * PI * fcC / AUDIO_FS;
  float sw = sinf(w0), cw = cosf(w0);
  float alpha = sw / (2.0f * Q);
  float b0 =  Q * alpha, b1 = 0.0f,      b2 = -Q * alpha;
  float a0 = 1.0f + alpha, a1 = -2.0f * cw, a2 = 1.0f - alpha;
  float ia0 = 1.0f / a0;                  // Inverse for normalisation
  b0*=ia0; b1*=ia0; b2*=ia0; a1*=ia0; a2*=ia0;

  /* --- Burst & envelope timing --- */
  const uint8_t  BURSTS = 3;                                 // 3 bursts fixed
  const uint32_t PULSE_INTERVAL = uint32_t(0.015f * AUDIO_FS);//15 ms gap
  const uint32_t BURST_LEN      = uint32_t(0.004f * AUDIO_FS);//4 ms gate

  const float tau_s = decay_ms / 1000.0f;                    // Decay constant (s)
  const float expK  = expf(-1.0f / (tau_s * AUDIO_FS));      // Per‑sample factor

  /* --- Envelope state --- */
  uint32_t nextOn  = 0;          // Next burst start sample index
  uint32_t nextOff = BURST_LEN;  // End of current gate
  uint8_t  current = 0;          // Burst counter
  bool     gateOn  = false;      // Gate active flag
  bool     tailActive = false;   // Tail (exponential) flag
  float    env = 0.0f;           // Tail envelope level

  /* --- Biquad history --- */
  float x1=0,x2=0,y1=0,y2=0;

  for(uint32_t i=0;i<TABLE_SZ;++i){
    /* Start new burst if scheduled */
    if(i == nextOn && current < BURSTS){
      if(current < BURSTS - 1){            // First two bursts → 4 ms gate
        gateOn  = true;
        nextOff = i + BURST_LEN;
      }else{                               // Final burst → exponential tail
        tailActive = true;
        env = 1.0f;                        // Reset envelope
      }
      current++;
      nextOn += PULSE_INTERVAL;            // Schedule next start
    }

    /* Gate ends after 4 ms */
    if(gateOn && i >= nextOff) gateOn = false;

    /* Current envelope value */
    float curEnv = 0.0f;
    if(gateOn)           curEnv = 1.0f;
    else if(tailActive){ curEnv = powf(env, DECAY_CURVE); env *= expK; }

    /* Apply envelope + accent to noise */
    float x0 = noiseTbl[i] * curEnv * volFactor;

    /* BPF filtering */
    float y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;
    x2 = x1; x1 = x0; y2 = y1; y1 = y0;

    /* Anti‑click fades at buffer edges */
    float fade = 1.0f;
    if(i < FADE_IN_SMP)                           fade = i / float(FADE_IN_SMP);
    else if(i > TABLE_SZ - FADE_OUT_SMP - 1)      fade = (TABLE_SZ - i - 1) / float(FADE_OUT_SMP);
    y0 *= fade;
    
    /* Store LED envelope value (curEnv already includes burst/tail logic) */
    float ledEnv = curEnv * fade;  // Apply fade to LED too
    envTbl[i] = uint16_t(ledEnv * PWM_FS);

    dst[i] = int16_t(constrain(y0, -1.0f, 1.0f) * PWM_MID * MASTER_ATTEN); // Store sample
  }
}

/**********************  === PWM ISR ===  *************************************/
void on_pwm_wrap(){                      // Called at ≈36.6 kHz from sliceIRQ
  pwm_clear_irq(sliceIRQ);               // Clear IRQ flag

  if(!playingClap){
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, uint16_t(PWM_MID));
    pwm_set_chan_level(sliceLED, PWM_CHAN_B, 0);  // LED off
    return;
  }
  
  // Audio output
  int32_t mix = outClap[idxClap];
  int32_t val = PWM_MID + int32_t(mix * AMP_SCALE); // Apply master gain
  if(val < 0) val = 0; else if(val > 1023) val = 1023; // Clip to 10‑bit
  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, uint16_t(val)); // Output sample
  
  // LED brightness based on envelope
  pwm_set_chan_level(sliceLED, PWM_CHAN_B, envTbl[idxClap]);
  
  idxClap++;
  if(idxClap >= TABLE_SZ){             // End of buffer → stop playback
    playingClap = false;
    idxClap     = 0;
    pwm_set_chan_level(sliceLED, PWM_CHAN_B, 0);  // Ensure LED is off
  }
}

/**********************  === ISRs ===  *****************************************/
// External trigger (GPIO7, rising‑edge)
void triggerISR(){
  volFactor = digitalRead(0) ? 0.5f : 1.0f;   // Read accent before latching
  reqTrig  = true;
}

// Manual trigger button (GPIO6, falling‑edge)
void manualButtonISR(){
  volFactor = digitalRead(0) ? 0.5f : 1.0f;   // Accent input same as above
  reqTrig  = true;
}

/**********************  === SETUP ===  ****************************************/
void setup(){
  /* --- ADC & random seed --- */
  analogReadResolution(ADC_RES_BITS);
  randomSeed(analogRead(26));          // Use floating ADC pin as entropy
  generateWhiteNoise();                // Build noise table once

  /* --- PWM for audio (sliceAudio) --- */
  pinMode(1, OUTPUT); gpio_set_function(1, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  pwm_set_clkdiv(sliceAudio, 1);       // Full speed clock
  pwm_set_wrap(sliceAudio, 1023);      // 10‑bit period
  pwm_set_enabled(sliceAudio, true);

  /* --- LED PWM output pin (GPIO5) --- */
  pinMode(5, OUTPUT);
  gpio_set_function(5, GPIO_FUNC_PWM);
  sliceLED = pwm_gpio_to_slice_num(5);       // GPIO5 uses slice 2, channel B
  pwm_set_clkdiv(sliceLED, 1);               // Full speed (150 MHz / 1)
  pwm_set_wrap(sliceLED, 1023);              // 10‑bit resolution
  pwm_set_chan_level(sliceLED, PWM_CHAN_B, 0); // Start with LED off
  pwm_set_enabled(sliceLED, true);

  /* --- PWM for IRQ timing (sliceIRQ) --- */
  pinMode(2, OUTPUT); gpio_set_function(2, GPIO_FUNC_PWM);
  sliceIRQ = pwm_gpio_to_slice_num(2);
  pwm_set_clkdiv(sliceIRQ, 1);
  pwm_set_wrap(sliceIRQ, 4095);        // 4096‑step → SYS_CLOCK/4096 ≈ 36.6 kHz
  pwm_set_enabled(sliceIRQ, true);

  pwm_clear_irq(sliceIRQ);
  pwm_set_irq_enabled(sliceIRQ, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  /* --- GPIO configuration --- */
  pinMode(0, INPUT);                                     // Accent input
  pinMode(7, INPUT); attachInterrupt(digitalPinToInterrupt(7), triggerISR, RISING);
  pinMode(6, INPUT_PULLUP); attachInterrupt(digitalPinToInterrupt(6), manualButtonISR, FALLING);
}

/**********************  === LOOP ===  *****************************************/
void loop(){
  /* --- Read potentiometers once per ms (loop runs ≈1 kHz) --- */
  float rawA0 = readADC(A0) / float(ADC_MAX_VAL);         // Q control (0→1)
  float rawA1 = readADC(A1) / float(ADC_MAX_VAL);         // Decay time control
  float norm2 = 1.0f - (readADC(A2) / float(ADC_MAX_VAL));// Fc inverted mapping

  bpfQ    = 0.5f + 3.5f * rawA0;                          // Map to 0.5–4.0
  decayMs = 20.0f + 180.0f * rawA1;                       // 20–200 ms
  fc      = 50.0f + 7950.0f * norm2;                      // 50 Hz–8 kHz

  /* --- If any ISR requested a trigger, render & start playback --- */
  if(reqTrig){
    reqTrig = false;
    buildClap(outClap, decayMs, fc, bpfQ);                // Offline render
    idxClap     = 0;
    playingClap = true;
  }

  delayMicroseconds(500);                                 // ≈1 kHz main loop
}
